#!/usr/bin/env perl

# PVE SMB Gateway CLI Tool
# Copyright (C) 2025 Eric Henderson <eric@gozippy.com>
# Dual-licensed under AGPL-3.0 and Commercial License
#
# Command-line interface for managing SMB Gateway shares

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;

# PVE API2 wrapper for SMB Gateway management
package PVE::SMBGatewayCLI;

use PVE::APIClient::LWP;
use PVE::APIClient::Credentials;

sub new {
    my ($class, %param) = @_;
    return bless \%param, $class;
}

sub api_call {
    my ($self, $method, $path, $data) = @_;
    
    my $client = PVE::APIClient::LWP->new();
    $client->set_credentials(PVE::APIClient::Credentials->new());
    
    my $url = "https://localhost:8006/api2/json$path";
    
    if ($method eq 'GET') {
        return $client->get($url);
    } elsif ($method eq 'POST') {
        return $client->post($url, $data);
    } elsif ($method eq 'DELETE') {
        return $client->delete($url);
    }
}

sub list_shares {
    my ($self) = @_;
    
    my $response = $self->api_call('GET', '/nodes/' . `hostname` . '/storage');
    chomp(my $hostname = `hostname`);
    
    my $shares = [];
    foreach my $storage (@{$response->{data}}) {
        if ($storage->{type} eq 'smbgateway') {
            push @$shares, {
                id => $storage->{storage},
                sharename => $storage->{sharename},
                mode => $storage->{mode},
                path => $storage->{path},
                status => $self->get_share_status($storage->{storage})
            };
        }
    }
    
    return $shares;
}

sub get_share_status {
    my ($self, $share_id) = @_;
    chomp(my $hostname = `hostname`);
    
    eval {
        my $response = $self->api_call('GET', "/nodes/$hostname/storage/$share_id/status");
        return $response->{data}->{status} || 'unknown';
    };
    
    return 'error';
}

sub get_vip_status {
    my ($self, $share_id) = @_;
    chomp(my $hostname = `hostname`);
    
    eval {
        my $response = $self->api_call('GET', "/nodes/$hostname/storage/$share_id/status");
        if ($response->{data}->{ctdb_status}) {
            return $response->{data}->{ctdb_status};
        }
        return { status => 'unknown', message => 'CTDB status not available' };
    };
    
    return { status => 'error', message => 'Failed to get CTDB status' };
}

sub trigger_failover {
    my ($self, $share_id, $target_node) = @_;
    chomp(my $hostname = `hostname`);
    
    my $data = {
        target_node => $target_node
    };
    
    my $response = $self->api_call('POST', "/nodes/$hostname/storage/$share_id/failover", $data);
}

sub test_ad_connectivity {
    my ($self, $domain, $username, $password, $ou) = @_;
    
    # Test DNS resolution
    print "Testing DNS resolution for $domain...\n";
    my $dns_result = `nslookup $domain 2>&1`;
    if ($dns_result =~ /Address:\s*(\d+\.\d+\.\d+\.\d+)/) {
        print "✓ Domain resolves to $1\n";
    } else {
        print "✗ Domain resolution failed\n";
        return 0;
    }
    
    # Test SRV records
    print "Testing SRV records...\n";
    my $srv_result = `nslookup -type=srv _ldap._tcp.$domain 2>&1`;
    if ($srv_result =~ /svr hostname/) {
        print "✓ LDAP SRV records found\n";
    } else {
        print "✗ No LDAP SRV records found\n";
    }
    
    # Test Kerberos authentication
    print "Testing Kerberos authentication...\n";
    my $kinit_result = `echo '$password' | kinit '$username@$domain' 2>&1`;
    if ($kinit_result =~ /Password incorrect/ || $kinit_result =~ /Client not found/) {
        print "✓ Kerberos authentication mechanism working\n";
        system('kdestroy >/dev/null 2>&1');
    } else {
        print "✗ Kerberos authentication failed: $kinit_result\n";
    }
    
    return 1;
}

sub get_ad_status {
    my ($self, $share_id) = @_;
    chomp(my $hostname = `hostname`);
    
    eval {
        my $response = $self->api_call('GET', "/nodes/$hostname/storage/$share_id/status");
        if ($response->{data}->{ad_status}) {
            return $response->{data}->{ad_status};
        }
        return { status => 'unknown', message => 'AD status not available' };
    };
    
    return { status => 'error', message => 'Failed to get AD status' };
}

sub get_ha_status {
    my ($self, $share_id) = @_;
    chomp(my $hostname = `hostname`);
    
    eval {
        my $response = $self->api_call('GET', "/nodes/$hostname/storage/$share_id/status");
        if ($response->{data}->{ctdb_status}) {
            return $response->{data}->{ctdb_status};
        }
        return { status => 'unknown', message => 'HA status not available' };
    };
    
    return { status => 'error', message => 'Failed to get HA status' };
}

sub test_ha_failover {
    my ($self, $share_id, $target_node) = @_;
    chomp(my $hostname = `hostname`);
    
    my $data = {
        target_node => $target_node
    };
    
    eval {
        my $response = $self->api_call('POST', "/nodes/$hostname/storage/$share_id/failover", $data);
        return $response->{data};
    };
    
    return { status => 'error', message => 'Failed to trigger HA failover' };
}

sub test_ha_connectivity {
    my ($self, $vip, $share) = @_;
    
    # Test SMB connectivity to VIP
    print "Testing SMB connectivity to VIP $vip...\n";
    my $smb_test = `timeout 10 smbclient -L //$vip -U guest% 2>/dev/null`;
    if ($smb_test && $smb_test !~ /error/i) {
        print "✓ SMB connectivity to VIP $vip successful\n";
        return 1;
    } else {
        print "✗ SMB connectivity to VIP $vip failed\n";
        return 0;
    }
}
    
    return $response;
}

sub create_share {
    my ($self, $sharename, $mode, $path, $quota, $ad_domain, $ctdb_vip, $ad_join, $ad_username, $ad_password, $ad_ou) = @_;
    
    chomp(my $hostname = `hostname`);
    
    my $data = {
        storage => $sharename,
        type => 'smbgateway',
        mode => $mode || 'lxc',
        sharename => $sharename,
        path => $path || "/srv/smb/$sharename"
    };
    
    $data->{quota} = $quota if $quota;
    $data->{ad_domain} = $ad_domain if $ad_domain;
    $data->{ctdb_vip} = $ctdb_vip if $ctdb_vip;
    
    # Add AD join parameters if specified
    if ($ad_domain && $ad_join) {
        $data->{ad_join} = 1;
        $data->{ad_username} = $ad_username if $ad_username;
        $data->{ad_password} = $ad_password if $ad_password;
        $data->{ad_ou} = $ad_ou if $ad_ou;
    }
    
    my $response = $self->api_call('POST', "/nodes/$hostname/storage", $data);
    
    return $response;
}

sub delete_share {
    my ($self, $share_id) = @_;
    
    chomp(my $hostname = `hostname`);
    
    my $response = $self->api_call('DELETE', "/nodes/$hostname/storage/$share_id");
    
    return $response;
}

# Main CLI interface
package main;

my $cli = PVE::SMBGatewayCLI->new();

my ($help, $mode, $path, $quota, $ad_domain, $ad_join, $ad_username, $ad_password, $ad_ou, $ctdb_vip);
my $result = GetOptions(
    "help|h" => \$help,
    "mode=s" => \$mode,
    "path=s" => \$path,
    "quota=s" => \$quota,
    "ad-domain=s" => \$ad_domain,
    "ad-join" => \$ad_join,
    "ad-username=s" => \$ad_username,
    "ad-password=s" => \$ad_password,
    "ad-ou=s" => \$ad_ou,
    "ctdb-vip=s" => \$ctdb_vip,
);

if ($help) {
    pod2usage(1);
}

my $command = shift @ARGV;
my $share_id = shift @ARGV;

die "Usage: $0 <command> [share_id] [options]\n" unless $command;

if ($command eq 'list') {
    my $shares = $cli->list_shares();
    
    if (@$shares == 0) {
        print "No SMB Gateway shares found.\n";
        exit 0;
    }
    
    printf "%-20s %-10s %-30s %-10s\n", "Share ID", "Mode", "Path", "Status";
    print "-" x 70 . "\n";
    
    foreach my $share (@$shares) {
        printf "%-20s %-10s %-30s %-10s\n", 
            $share->{id}, 
            $share->{mode}, 
            $share->{path}, 
            $share->{status};
    }
    
} elsif ($command eq 'create') {
    die "Usage: $0 create <sharename> [options]\n" unless $share_id;
    
    print "Creating SMB Gateway share '$share_id'...\n";
    
    my $response = $cli->create_share($share_id, $mode, $path, $quota, $ad_domain, $ctdb_vip, $ad_join, $ad_username, $ad_password, $ad_ou);
    
    if ($response->{success}) {
        print "Share '$share_id' created successfully.\n";
    } else {
        print "Failed to create share: " . ($response->{message} || 'Unknown error') . "\n";
        exit 1;
    }
    
} elsif ($command eq 'delete') {
    die "Usage: $0 delete <share_id>\n" unless $share_id;
    
    print "Deleting SMB Gateway share '$share_id'...\n";
    
    my $response = $cli->delete_share($share_id);
    
    if ($response->{success}) {
        print "Share '$share_id' deleted successfully.\n";
    } else {
        print "Failed to delete share: " . ($response->{message} || 'Unknown error') . "\n";
        exit 1;
    }
    
} elsif ($command eq 'status') {
    die "Usage: $0 status <share_id>\n" unless $share_id;
    
    my $status = $cli->get_share_status($share_id);
    print "Share '$share_id' status: $status\n";
    
} elsif ($command eq 'vip-status') {
    die "Usage: $0 vip-status <share_id>\n" unless $share_id;
    
    my $status = $cli->get_vip_status($share_id);
    
    if (ref($status) eq 'HASH') {
        print "VIP status for share '$share_id':\n";
        print "  Status: $status->{status}\n";
        print "  Message: $status->{message}\n";
        
        if ($status->{active_node}) {
            print "  Active node: $status->{active_node}\n";
        }
        
        if (ref($status->{nodes}) eq 'HASH') {
            print "  Nodes:\n";
            foreach my $node (keys %{$status->{nodes}}) {
                my $node_status = $status->{nodes}->{$node};
                print "    $node:\n";
                print "      Has VIP: " . ($node_status->{has_vip} ? "Yes" : "No") . "\n";
                print "      CTDB status: $node_status->{ctdb_status}\n";
                print "      SMB status: $node_status->{smb_status}\n";
            }
        }
    } else {
        print "Failed to get VIP status: $status\n";
    }
    
} elsif ($command eq 'ad-test') {
    die "Usage: $0 ad-test --domain <domain> --username <username> --password <password> [--ou <ou>]\n" unless $ad_domain && $ad_username && $ad_password;
    
    print "Testing Active Directory connectivity...\n";
    
    my $result = $cli->test_ad_connectivity($ad_domain, $ad_username, $ad_password, $ad_ou);
    
    if ($result) {
        print "✓ AD connectivity test completed successfully\n";
    } else {
        print "✗ AD connectivity test failed\n";
        exit 1;
    }
    
} elsif ($command eq 'ad-status') {
    die "Usage: $0 ad-status <share_id>\n" unless $share_id;
    
    my $status = $cli->get_ad_status($share_id);
    
    if (ref($status) eq 'HASH') {
        print "AD status for share '$share_id':\n";
        print "  Status: $status->{status}\n";
        print "  Message: $status->{message}\n";
        
        if ($status->{domain}) {
            print "  Domain: $status->{domain}\n";
        }
        
        if ($status->{realm}) {
            print "  Realm: $status->{realm}\n";
        }
        
        if ($status->{workgroup}) {
            print "  Workgroup: $status->{workgroup}\n";
        }
        
        if ($status->{joined}) {
            print "  Domain joined: " . ($status->{joined} ? "Yes" : "No") . "\n";
        }
        
        if ($status->{fallback_user}) {
            print "  Fallback user: $status->{fallback_user}\n";
        }
    } else {
        print "Failed to get AD status: $status\n";
    }
    
} elsif ($command eq 'ha-status') {
    die "Usage: $0 ha-status <share_id>\n" unless $share_id;
    
    my $status = $cli->get_ha_status($share_id);
    
    if (ref($status) eq 'HASH') {
        print "HA status for share '$share_id':\n";
        print "  Status: $status->{status}\n";
        print "  Message: $status->{message}\n";
        
        if ($status->{cluster_healthy}) {
            print "  Cluster healthy: " . ($status->{cluster_healthy} ? "Yes" : "No") . "\n";
        }
        
        if ($status->{vip_active}) {
            print "  VIP active: " . ($status->{vip_active} ? "Yes" : "No") . "\n";
        }
        
        if ($status->{active_vip}) {
            print "  Active VIP: $status->{active_vip}\n";
        }
        
        if ($status->{nodes_online}) {
            print "  Nodes online: $status->{nodes_online}\n";
        }
        
        if ($status->{total_nodes}) {
            print "  Total nodes: $status->{total_nodes}\n";
        }
        
        if ($status->{active_node}) {
            print "  Active node: $status->{active_node}\n";
        }
    } else {
        print "Failed to get HA status: $status\n";
    }
    
} elsif ($command eq 'ha-test') {
    die "Usage: $0 ha-test --vip <vip> --share <share> [--target-node <node>]\n" unless $ctdb_vip;
    
    print "Testing HA functionality...\n";
    
    # Test VIP connectivity
    my $connectivity_result = $cli->test_ha_connectivity($ctdb_vip, $share_id);
    
    if ($connectivity_result) {
        print "✓ VIP connectivity test passed\n";
    } else {
        print "✗ VIP connectivity test failed\n";
    }
    
    # Test failover if target node specified
    if ($target_node) {
        print "Testing failover to node $target_node...\n";
        my $failover_result = $cli->test_ha_failover($share_id, $target_node);
        
        if (ref($failover_result) eq 'HASH' && $failover_result->{success}) {
            print "✓ Failover test successful\n";
        } else {
            print "✗ Failover test failed\n";
        }
    }
    
} elsif ($command eq 'ha-failover') {
    die "Usage: $0 ha-failover <share_id> --target-node <node>\n" unless $share_id && $target_node;
    
    print "Triggering HA failover for share '$share_id' to node '$target_node'...\n";
    
    my $result = $cli->test_ha_failover($share_id, $target_node);
    
    if (ref($result) eq 'HASH' && $result->{success}) {
        print "✓ HA failover triggered successfully\n";
    } else {
        print "✗ HA failover failed: " . ($result->{message} || 'Unknown error') . "\n";
        exit 1;
    }
        print "VIP status for share '$share_id': $status\n";
    }
    
} elsif ($command eq 'failover') {
    die "Usage: $0 failover <share_id> <target_node>\n" unless $share_id && $ARGV[0];
    
    my $target_node = $ARGV[0];
    print "Triggering failover for share '$share_id' to node '$target_node'...\n";
    
    my $response = $cli->trigger_failover($share_id, $target_node);
    
    if ($response->{success}) {
        print "Failover successful: " . ($response->{message} || 'VIP moved to target node') . "\n";
    } else {
        print "Failover failed: " . ($response->{message} || 'Unknown error') . "\n";
        exit 1;
    }
    
} elsif ($command eq 'logs') {
    # Show operation logs
    my $log_dir = '/var/log/pve';
    my $operation_log = "$log_dir/smbgateway-operations.log";
    my $error_log = "$log_dir/smbgateway-errors.log";
    my $audit_log = "$log_dir/smbgateway-audit.log";
    
    if ($operation_id) {
        # Show logs for specific operation
        print "=== Logs for Operation: $operation_id ===\n";
        foreach my $log_file ($operation_log, $error_log, $audit_log) {
            if (-f $log_file) {
                my $grep_result = `grep "$operation_id" "$log_file" 2>/dev/null`;
                if ($grep_result) {
                    print "--- $log_file ---\n";
                    print $grep_result;
                    print "\n";
                }
            }
        }
    } else {
        # Show recent logs
        print "=== Recent Operation Logs ===\n";
        if (-f $operation_log) {
            print "--- Operations Log (last 10 lines) ---\n";
            system("tail -10 '$operation_log'");
            print "\n";
        }
        
        if (-f $error_log) {
            print "--- Error Log (last 10 lines) ---\n";
            system("tail -10 '$error_log'");
            print "\n";
        }
        
        if (-f $audit_log) {
            print "--- Audit Log (last 10 lines) ---\n";
            system("tail -10 '$audit_log'");
            print "\n";
        }
    }
    
} elsif ($command eq 'cleanup') {
    # Manual cleanup operations
    my $cleanup_type = shift @ARGV;
    
    if ($cleanup_type eq 'status') {
        # Show cleanup status
        print "=== SMB Gateway Cleanup Status ===\n";
        
        # Check for containers
        my $containers = `pct list 2>/dev/null | grep smbgateway || true`;
        if ($containers) {
            print "SMB Gateway Containers:\n";
            print $containers;
            print "\n";
        } else {
            print "No SMB Gateway containers found\n";
        }
        
        # Check for VMs
        my $vms = `qm list 2>/dev/null | grep smbgateway || true`;
        if ($vms) {
            print "SMB Gateway VMs:\n";
            print $vms;
            print "\n";
        } else {
            print "No SMB Gateway VMs found\n";
        }
        
        # Check for Samba shares
        if (-f '/etc/samba/smb.conf') {
            my $shares = `grep '^\[' /etc/samba/smb.conf | grep -v '^\[global\]' | grep -v '^\[homes\]' | grep -v '^\[printers\]' || true`;
            if ($shares) {
                print "Samba Shares:\n";
                print $shares;
                print "\n";
            } else {
                print "No Samba shares found\n";
            }
        }
        
        # Check for CTDB
        if (-d '/etc/ctdb') {
            print "CTDB configuration found: /etc/ctdb\n";
        } else {
            print "No CTDB configuration found\n";
        }
        
        # Check for AD domain
        my $realm_status = `realm list 2>/dev/null || echo "none"`;
        if ($realm_status ne "none") {
            print "AD Domain Status:\n";
            print $realm_status;
            print "\n";
        } else {
            print "No AD domain joined\n";
        }
        
    } elsif ($cleanup_type eq 'report') {
        # Generate cleanup report
        my $report_file = "/tmp/smbgateway-cleanup-report-" . time() . ".json";
        
        my $report = {
            timestamp => POSIX::strftime('%Y-%m-%d %H:%M:%S', localtime),
            system_status => {},
            recommendations => []
        };
        
        # Get system status
        my $containers = `pct list 2>/dev/null | grep smbgateway || true`;
        $report->{system_status}->{containers} = $containers ? scalar(split(/\n/, $containers)) : 0;
        
        my $vms = `qm list 2>/dev/null | grep smbgateway || true`;
        $report->{system_status}->{vms} = $vms ? scalar(split(/\n/, $vms)) : 0;
        
        if (-f '/etc/samba/smb.conf') {
            $report->{system_status}->{samba_shares} = `grep -c '^\[' /etc/samba/smb.conf`;
        } else {
            $report->{system_status}->{samba_shares} = 0;
        }
        
        $report->{system_status}->{ctdb_configured} = -d '/etc/ctdb' ? 1 : 0;
        $report->{system_status}->{ad_joined} = `realm list 2>/dev/null` ? 1 : 0;
        
        # Generate recommendations
        if ($containers) {
            foreach my $line (split(/\n/, $containers)) {
                my ($vmid, $status, $name) = split(/\s+/, $line);
                push @{$report->{recommendations}}, {
                    type => 'container',
                    id => $vmid,
                    name => $name,
                    status => $status,
                    action => "pct destroy $vmid"
                };
            }
        }
        
        if ($vms) {
            foreach my $line (split(/\n/, $vms)) {
                my ($vmid, $status, $name) = split(/\s+/, $line);
                push @{$report->{recommendations}}, {
                    type => 'vm',
                    id => $vmid,
                    name => $name,
                    status => $status,
                    action => "qm destroy $vmid"
                };
            }
        }
        
        # Write report
        use JSON::PP;
        open(my $fh, '>', $report_file) or die "Cannot write report: $!";
        print $fh encode_json($report);
        close($fh);
        
        print "Cleanup report generated: $report_file\n";
        print "Report contents:\n";
        print encode_json($report);
        print "\n";
        
    } else {
        die "Unknown cleanup type '$cleanup_type'. Use 'status' or 'report'.\n";
    }
    
} else {
    die "Unknown command '$command'. Use 'list', 'create', 'delete', 'status', 'vip-status', 'failover', 'logs', or 'cleanup'.\n";
}

__END__

=head1 NAME

pve-smbgateway - Proxmox VE SMB Gateway management CLI

=head1 SYNOPSIS

  pve-smbgateway list
  pve-smbgateway create <sharename> [options]
  pve-smbgateway delete <share_id>
  pve-smbgateway status <share_id>
  pve-smbgateway vip-status <share_id>
  pve-smbgateway failover <share_id> <target_node>
  pve-smbgateway logs [--operation-id <id>]
  pve-smbgateway cleanup status
  pve-smbgateway cleanup report

=head1 OPTIONS

=over 4

=item B<--mode> (lxc|native|vm)

Deployment mode for the share (default: lxc)

=item B<--path> <path>

Path for the share (default: /srv/smb/<sharename>)

=item B<--quota> <size>

Quota for the share (e.g., 10G, 1T)

=item B<--ad-domain> <domain>

Active Directory domain for authentication

=item B<--ad-join>

Join the Active Directory domain (requires --ad-domain)

=item B<--ad-username> <username>

Username for Active Directory domain join (default: Administrator)

=item B<--ad-password> <password>

Password for Active Directory domain join

=item B<--ad-ou> <ou>

Organizational Unit for computer account in Active Directory

=item B<--ctdb-vip> <ip>

CTDB virtual IP for HA failover

=item B<--operation-id> <id>

Operation ID for targeted log viewing

=back

=head1 EXAMPLES

  # List all SMB Gateway shares
  pve-smbgateway list

  # Create a new share in LXC mode
  pve-smbgateway create myshare --mode lxc --quota 10G

  # Create a share with AD integration
  pve-smbgateway create officeshare --mode native --ad-domain example.com

  # Create a share and join AD domain
  pve-smbgateway create adshare --mode lxc --ad-domain example.com --ad-join --ad-password "secret"

  # Create a share with HA support
  pve-smbgateway create hashare --mode lxc --ctdb-vip 192.168.1.100

  # Check share status
  pve-smbgateway status myshare

  # Check VIP status for HA share
  pve-smbgateway vip-status hashare

  # Trigger failover to another node
  pve-smbgateway failover hashare pve2

  # Show operation logs
  pve-smbgateway logs
  pve-smbgateway logs --operation-id create_storage_1234567890_1234

  # Check cleanup status
  pve-smbgateway cleanup status
  pve-smbgateway cleanup report

  # Delete a share
  pve-smbgateway delete myshare

=cut 